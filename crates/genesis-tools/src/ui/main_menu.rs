//! Main Menu UI
//!
//! The primary game menu displayed on startup with options for
//! starting a new game, continuing, loading saves, options, and exit.

use egui::{Color32, Ui};
use serde::{Deserialize, Serialize};

/// Unique identifier for menu items
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct MenuItemId(pub u32);

impl MenuItemId {
    /// Create a new menu item ID
    pub fn new(id: u32) -> Self {
        Self(id)
    }
}

impl std::fmt::Display for MenuItemId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "MenuItem-{}", self.0)
    }
}

/// Menu button types
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default, Serialize, Deserialize)]
pub enum MainMenuButton {
    /// Start a new game
    #[default]
    NewGame,
    /// Continue from last save
    Continue,
    /// Open load game menu
    LoadGame,
    /// Open options menu
    Options,
    /// Exit the game
    Exit,
}

impl MainMenuButton {
    /// Get all menu buttons in display order
    pub fn all() -> &'static [Self] {
        &[
            Self::NewGame,
            Self::Continue,
            Self::LoadGame,
            Self::Options,
            Self::Exit,
        ]
    }

    /// Get display text for the button
    pub fn display_text(&self) -> &'static str {
        match self {
            Self::NewGame => "New Game",
            Self::Continue => "Continue",
            Self::LoadGame => "Load Game",
            Self::Options => "Options",
            Self::Exit => "Exit",
        }
    }

    /// Get hotkey hint
    pub fn hotkey_hint(&self) -> Option<&'static str> {
        match self {
            Self::NewGame => Some("N"),
            Self::Continue => Some("C"),
            Self::LoadGame => Some("L"),
            Self::Options => Some("O"),
            Self::Exit => Some("Esc"),
        }
    }

    /// Get button icon
    pub fn icon(&self) -> &'static str {
        match self {
            Self::NewGame => "ðŸ†•",
            Self::Continue => "â–¶",
            Self::LoadGame => "ðŸ“‚",
            Self::Options => "âš™",
            Self::Exit => "ðŸšª",
        }
    }
}

/// Actions generated by the main menu
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum MainMenuAction {
    /// Start a new game
    NewGame,
    /// Continue from last save
    Continue,
    /// Open load game menu
    OpenLoadMenu,
    /// Open options menu
    OpenOptions,
    /// Exit the game
    Exit,
    /// Navigate to previous button
    NavigateUp,
    /// Navigate to next button
    NavigateDown,
    /// Confirm selection
    Confirm,
}

/// Navigation direction for keyboard control
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum NavigationDirection {
    /// Move up in the menu
    Up,
    /// Move down in the menu
    Down,
}

/// State of a menu button
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default, Serialize, Deserialize)]
pub enum ButtonState {
    /// Button is in normal state
    #[default]
    Normal,
    /// Button is hovered
    Hovered,
    /// Button is pressed/active
    Pressed,
    /// Button is disabled
    Disabled,
}

impl ButtonState {
    /// Check if button is interactive
    pub fn is_interactive(&self) -> bool {
        !matches!(self, Self::Disabled)
    }

    /// Get background color for state
    pub fn background_color(&self) -> Color32 {
        match self {
            Self::Normal => Color32::from_rgba_unmultiplied(40, 40, 50, 200),
            Self::Hovered => Color32::from_rgba_unmultiplied(60, 60, 80, 220),
            Self::Pressed => Color32::from_rgba_unmultiplied(80, 80, 100, 255),
            Self::Disabled => Color32::from_rgba_unmultiplied(30, 30, 35, 150),
        }
    }

    /// Get text color for state
    pub fn text_color(&self) -> Color32 {
        match self {
            Self::Normal => Color32::from_gray(200),
            Self::Hovered | Self::Pressed => Color32::from_gray(255),
            Self::Disabled => Color32::from_gray(100),
        }
    }
}

/// Configuration for main menu appearance
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MainMenuConfig {
    /// Title text
    pub title: String,
    /// Subtitle/tagline text
    pub subtitle: String,
    /// Version string to display
    pub version: String,
    /// Background color
    pub background_color: [u8; 4],
    /// Title color
    pub title_color: [u8; 4],
    /// Button width
    pub button_width: f32,
    /// Button height
    pub button_height: f32,
    /// Button spacing
    pub button_spacing: f32,
    /// Show button icons
    pub show_icons: bool,
    /// Show hotkey hints
    pub show_hotkeys: bool,
    /// Animation duration for transitions
    pub animation_duration: f32,
}

impl Default for MainMenuConfig {
    fn default() -> Self {
        Self {
            title: String::from("Project Genesis"),
            subtitle: String::from("A World Awaits"),
            version: String::from("v0.1.0"),
            background_color: [20, 20, 30, 255],
            title_color: [200, 180, 100, 255],
            button_width: 200.0,
            button_height: 48.0,
            button_spacing: 12.0,
            show_icons: true,
            show_hotkeys: true,
            animation_duration: 0.2,
        }
    }
}

/// Save availability information
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct SaveAvailability {
    /// Whether any save exists
    pub has_saves: bool,
    /// Whether a recent save exists for Continue
    pub has_continue_save: bool,
    /// Name of the most recent save
    pub last_save_name: Option<String>,
    /// Formatted time since last save
    pub last_save_time: Option<String>,
}

impl SaveAvailability {
    /// Create with no saves available
    pub fn none() -> Self {
        Self::default()
    }

    /// Create with saves available
    pub fn with_saves(last_name: impl Into<String>, last_time: impl Into<String>) -> Self {
        Self {
            has_saves: true,
            has_continue_save: true,
            last_save_name: Some(last_name.into()),
            last_save_time: Some(last_time.into()),
        }
    }

    /// Set whether continue is available
    pub fn with_continue(mut self, available: bool) -> Self {
        self.has_continue_save = available;
        self
    }
}

/// Main menu state
#[derive(Debug, Clone)]
pub struct MainMenu {
    /// Configuration
    config: MainMenuConfig,
    /// Currently selected button index
    selected_index: usize,
    /// Button states
    button_states: Vec<ButtonState>,
    /// Save availability
    save_availability: SaveAvailability,
    /// Whether menu is visible
    visible: bool,
    /// Pending actions
    actions: Vec<MainMenuAction>,
    /// Animation time for effects
    animation_time: f32,
    /// Keyboard navigation enabled
    keyboard_nav_enabled: bool,
}

impl MainMenu {
    /// Create a new main menu
    pub fn new(config: MainMenuConfig) -> Self {
        let button_count = MainMenuButton::all().len();
        let mut menu = Self {
            config,
            selected_index: 0,
            button_states: vec![ButtonState::Normal; button_count],
            save_availability: SaveAvailability::none(),
            visible: true,
            actions: Vec::new(),
            animation_time: 0.0,
            keyboard_nav_enabled: true,
        };
        menu.update_button_states();
        menu
    }

    /// Create with default configuration
    pub fn with_defaults() -> Self {
        Self::new(MainMenuConfig::default())
    }

    /// Get the configuration
    pub fn config(&self) -> &MainMenuConfig {
        &self.config
    }

    /// Get mutable configuration
    pub fn config_mut(&mut self) -> &mut MainMenuConfig {
        &mut self.config
    }

    /// Set visibility
    pub fn set_visible(&mut self, visible: bool) {
        self.visible = visible;
    }

    /// Check if visible
    pub fn is_visible(&self) -> bool {
        self.visible
    }

    /// Show the menu
    pub fn show(&mut self) {
        self.visible = true;
        self.selected_index = 0;
        self.update_button_states();
    }

    /// Hide the menu
    pub fn hide(&mut self) {
        self.visible = false;
    }

    /// Toggle visibility
    pub fn toggle(&mut self) {
        if self.visible {
            self.hide();
        } else {
            self.show();
        }
    }

    /// Set save availability
    pub fn set_save_availability(&mut self, availability: SaveAvailability) {
        self.save_availability = availability;
        self.update_button_states();
    }

    /// Get save availability
    pub fn save_availability(&self) -> &SaveAvailability {
        &self.save_availability
    }

    /// Get currently selected button
    pub fn selected_button(&self) -> MainMenuButton {
        MainMenuButton::all()[self.selected_index]
    }

    /// Get selected index
    pub fn selected_index(&self) -> usize {
        self.selected_index
    }

    /// Set selected index
    pub fn set_selected_index(&mut self, index: usize) {
        let max_index = MainMenuButton::all().len().saturating_sub(1);
        self.selected_index = index.min(max_index);
        self.update_button_states();
    }

    /// Navigate in a direction
    pub fn navigate(&mut self, direction: NavigationDirection) {
        let buttons = MainMenuButton::all();
        let len = buttons.len();

        match direction {
            NavigationDirection::Up => {
                // Find previous enabled button
                let mut new_index = if self.selected_index == 0 {
                    len - 1
                } else {
                    self.selected_index - 1
                };

                // Skip disabled buttons
                let start = new_index;
                while self.button_states[new_index] == ButtonState::Disabled {
                    new_index = if new_index == 0 {
                        len - 1
                    } else {
                        new_index - 1
                    };
                    if new_index == start {
                        break;
                    }
                }

                self.selected_index = new_index;
            },
            NavigationDirection::Down => {
                // Find next enabled button
                let mut new_index = (self.selected_index + 1) % len;

                // Skip disabled buttons
                let start = new_index;
                while self.button_states[new_index] == ButtonState::Disabled {
                    new_index = (new_index + 1) % len;
                    if new_index == start {
                        break;
                    }
                }

                self.selected_index = new_index;
            },
        }

        self.update_button_states();
    }

    /// Confirm the current selection
    pub fn confirm_selection(&mut self) {
        let button = self.selected_button();
        if self.button_states[self.selected_index] == ButtonState::Disabled {
            return;
        }

        let action = match button {
            MainMenuButton::NewGame => MainMenuAction::NewGame,
            MainMenuButton::Continue => MainMenuAction::Continue,
            MainMenuButton::LoadGame => MainMenuAction::OpenLoadMenu,
            MainMenuButton::Options => MainMenuAction::OpenOptions,
            MainMenuButton::Exit => MainMenuAction::Exit,
        };

        self.actions.push(action);
    }

    /// Handle button click
    pub fn click_button(&mut self, button: MainMenuButton) {
        let index = MainMenuButton::all()
            .iter()
            .position(|b| *b == button)
            .unwrap_or(0);

        if self.button_states[index] == ButtonState::Disabled {
            return;
        }

        self.selected_index = index;
        self.confirm_selection();
    }

    /// Enable/disable keyboard navigation
    pub fn set_keyboard_nav_enabled(&mut self, enabled: bool) {
        self.keyboard_nav_enabled = enabled;
    }

    /// Check if keyboard navigation is enabled
    pub fn keyboard_nav_enabled(&self) -> bool {
        self.keyboard_nav_enabled
    }

    /// Update animation time
    pub fn update(&mut self, delta_time: f32) {
        self.animation_time += delta_time;
    }

    /// Get animation time
    pub fn animation_time(&self) -> f32 {
        self.animation_time
    }

    /// Drain pending actions
    pub fn drain_actions(&mut self) -> Vec<MainMenuAction> {
        std::mem::take(&mut self.actions)
    }

    /// Check if there are pending actions
    pub fn has_actions(&self) -> bool {
        !self.actions.is_empty()
    }

    /// Get button state for a specific button
    pub fn button_state(&self, button: MainMenuButton) -> ButtonState {
        let index = MainMenuButton::all()
            .iter()
            .position(|b| *b == button)
            .unwrap_or(0);
        self.button_states[index]
    }

    /// Update button states based on current state
    fn update_button_states(&mut self) {
        let buttons = MainMenuButton::all();
        for (i, button) in buttons.iter().enumerate() {
            let state = if self.is_button_disabled(*button) {
                ButtonState::Disabled
            } else if i == self.selected_index {
                ButtonState::Hovered
            } else {
                ButtonState::Normal
            };
            self.button_states[i] = state;
        }
    }

    /// Check if a button should be disabled
    fn is_button_disabled(&self, button: MainMenuButton) -> bool {
        match button {
            MainMenuButton::Continue => !self.save_availability.has_continue_save,
            MainMenuButton::LoadGame => !self.save_availability.has_saves,
            _ => false,
        }
    }

    /// Render the main menu
    pub fn render(&mut self, ui: &mut Ui) {
        if !self.visible {
            return;
        }

        let bg = Color32::from_rgba_unmultiplied(
            self.config.background_color[0],
            self.config.background_color[1],
            self.config.background_color[2],
            self.config.background_color[3],
        );

        egui::Frame::none()
            .fill(bg)
            .inner_margin(32.0)
            .show(ui, |ui| {
                ui.vertical_centered(|ui| {
                    self.render_title(ui);
                    ui.add_space(48.0);
                    self.render_buttons(ui);
                    ui.add_space(32.0);
                    self.render_version(ui);
                });
            });
    }

    fn render_title(&self, ui: &mut Ui) {
        let title_color = Color32::from_rgba_unmultiplied(
            self.config.title_color[0],
            self.config.title_color[1],
            self.config.title_color[2],
            self.config.title_color[3],
        );

        ui.label(
            egui::RichText::new(&self.config.title)
                .size(48.0)
                .color(title_color)
                .strong(),
        );

        if !self.config.subtitle.is_empty() {
            ui.label(
                egui::RichText::new(&self.config.subtitle)
                    .size(18.0)
                    .color(Color32::from_gray(150))
                    .italics(),
            );
        }
    }

    fn render_buttons(&mut self, ui: &mut Ui) {
        let buttons = MainMenuButton::all();

        for (i, button) in buttons.iter().enumerate() {
            let state = self.button_states[i];

            let button_size = egui::vec2(self.config.button_width, self.config.button_height);
            let (rect, response) = ui.allocate_exact_size(button_size, egui::Sense::click());

            // Update hover state
            if state.is_interactive() {
                if response.hovered() && self.selected_index != i {
                    self.selected_index = i;
                    self.update_button_states();
                }

                if response.clicked() {
                    self.click_button(*button);
                }
            }

            // Draw button background
            let current_state = self.button_states[i];
            ui.painter()
                .rect_filled(rect, 4.0, current_state.background_color());

            // Draw button content
            let mut text = String::new();
            if self.config.show_icons {
                text.push_str(button.icon());
                text.push(' ');
            }
            text.push_str(button.display_text());

            if self.config.show_hotkeys {
                if let Some(hotkey) = button.hotkey_hint() {
                    use std::fmt::Write;
                    let _ = write!(text, " [{hotkey}]");
                }
            }

            ui.painter().text(
                rect.center(),
                egui::Align2::CENTER_CENTER,
                text,
                egui::FontId::proportional(18.0),
                current_state.text_color(),
            );

            // Show continue info for Continue button
            if *button == MainMenuButton::Continue && state != ButtonState::Disabled {
                if let Some(ref name) = self.save_availability.last_save_name {
                    let info_rect =
                        rect.translate(egui::vec2(0.0, self.config.button_height * 0.3));
                    ui.painter().text(
                        info_rect.center(),
                        egui::Align2::CENTER_TOP,
                        name,
                        egui::FontId::proportional(12.0),
                        Color32::from_gray(120),
                    );
                }
            }

            ui.add_space(self.config.button_spacing);
        }
    }

    fn render_version(&self, ui: &mut Ui) {
        ui.label(
            egui::RichText::new(&self.config.version)
                .size(12.0)
                .color(Color32::from_gray(80)),
        );
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_menu_item_id() {
        let id = MenuItemId::new(42);
        assert_eq!(id.0, 42);
        assert_eq!(format!("{id}"), "MenuItem-42");
    }

    #[test]
    fn test_main_menu_button_all() {
        let buttons = MainMenuButton::all();
        assert_eq!(buttons.len(), 5);
        assert_eq!(buttons[0], MainMenuButton::NewGame);
        assert_eq!(buttons[4], MainMenuButton::Exit);
    }

    #[test]
    fn test_main_menu_button_display_text() {
        assert_eq!(MainMenuButton::NewGame.display_text(), "New Game");
        assert_eq!(MainMenuButton::Continue.display_text(), "Continue");
        assert_eq!(MainMenuButton::LoadGame.display_text(), "Load Game");
        assert_eq!(MainMenuButton::Options.display_text(), "Options");
        assert_eq!(MainMenuButton::Exit.display_text(), "Exit");
    }

    #[test]
    fn test_main_menu_button_hotkey() {
        assert_eq!(MainMenuButton::NewGame.hotkey_hint(), Some("N"));
        assert_eq!(MainMenuButton::Exit.hotkey_hint(), Some("Esc"));
    }

    #[test]
    fn test_main_menu_button_icon() {
        assert_eq!(MainMenuButton::NewGame.icon(), "ðŸ†•");
        assert_eq!(MainMenuButton::Options.icon(), "âš™");
    }

    #[test]
    fn test_button_state_is_interactive() {
        assert!(ButtonState::Normal.is_interactive());
        assert!(ButtonState::Hovered.is_interactive());
        assert!(ButtonState::Pressed.is_interactive());
        assert!(!ButtonState::Disabled.is_interactive());
    }

    #[test]
    fn test_button_state_colors() {
        let normal = ButtonState::Normal;
        let disabled = ButtonState::Disabled;

        assert_ne!(normal.background_color(), disabled.background_color());
        assert_ne!(normal.text_color(), disabled.text_color());
    }

    #[test]
    fn test_main_menu_config_defaults() {
        let config = MainMenuConfig::default();
        assert_eq!(config.title, "Project Genesis");
        assert!(!config.subtitle.is_empty());
        assert!(config.button_width > 0.0);
        assert!(config.button_height > 0.0);
        assert!(config.show_icons);
        assert!(config.show_hotkeys);
    }

    #[test]
    fn test_save_availability_none() {
        let avail = SaveAvailability::none();
        assert!(!avail.has_saves);
        assert!(!avail.has_continue_save);
        assert!(avail.last_save_name.is_none());
    }

    #[test]
    fn test_save_availability_with_saves() {
        let avail = SaveAvailability::with_saves("Hero", "5 minutes ago");
        assert!(avail.has_saves);
        assert!(avail.has_continue_save);
        assert_eq!(avail.last_save_name, Some(String::from("Hero")));
        assert_eq!(avail.last_save_time, Some(String::from("5 minutes ago")));
    }

    #[test]
    fn test_save_availability_with_continue() {
        let avail = SaveAvailability::with_saves("Hero", "5 minutes ago").with_continue(false);
        assert!(avail.has_saves);
        assert!(!avail.has_continue_save);
    }

    #[test]
    fn test_main_menu_new() {
        let menu = MainMenu::with_defaults();
        assert!(menu.is_visible());
        assert_eq!(menu.selected_index(), 0);
        assert_eq!(menu.selected_button(), MainMenuButton::NewGame);
    }

    #[test]
    fn test_main_menu_visibility() {
        let mut menu = MainMenu::with_defaults();
        assert!(menu.is_visible());

        menu.hide();
        assert!(!menu.is_visible());

        menu.show();
        assert!(menu.is_visible());

        menu.toggle();
        assert!(!menu.is_visible());
    }

    #[test]
    fn test_main_menu_navigate_down() {
        let mut menu = MainMenu::with_defaults();
        // Enable saves so all buttons are enabled
        menu.set_save_availability(SaveAvailability::with_saves("Test", "Now"));

        assert_eq!(menu.selected_index(), 0);

        menu.navigate(NavigationDirection::Down);
        assert_eq!(menu.selected_index(), 1);

        menu.navigate(NavigationDirection::Down);
        assert_eq!(menu.selected_index(), 2);
    }

    #[test]
    fn test_main_menu_navigate_up() {
        let mut menu = MainMenu::with_defaults();
        // Enable saves so all buttons are enabled
        menu.set_save_availability(SaveAvailability::with_saves("Test", "Now"));
        menu.set_selected_index(2);

        menu.navigate(NavigationDirection::Up);
        assert_eq!(menu.selected_index(), 1);

        menu.navigate(NavigationDirection::Up);
        assert_eq!(menu.selected_index(), 0);
    }

    #[test]
    fn test_main_menu_navigate_wrap() {
        let mut menu = MainMenu::with_defaults();
        assert_eq!(menu.selected_index(), 0);

        menu.navigate(NavigationDirection::Up);
        assert_eq!(menu.selected_index(), 4); // Wrapped to last

        menu.navigate(NavigationDirection::Down);
        assert_eq!(menu.selected_index(), 0); // Wrapped to first
    }

    #[test]
    fn test_main_menu_confirm_selection() {
        let mut menu = MainMenu::with_defaults();
        menu.confirm_selection();

        let actions = menu.drain_actions();
        assert_eq!(actions.len(), 1);
        assert_eq!(actions[0], MainMenuAction::NewGame);
    }

    #[test]
    fn test_main_menu_click_button() {
        let mut menu = MainMenu::with_defaults();
        menu.click_button(MainMenuButton::Options);

        let actions = menu.drain_actions();
        assert_eq!(actions.len(), 1);
        assert_eq!(actions[0], MainMenuAction::OpenOptions);
    }

    #[test]
    fn test_main_menu_disabled_buttons() {
        let mut menu = MainMenu::with_defaults();

        // Without saves, Continue and LoadGame should be disabled
        assert_eq!(
            menu.button_state(MainMenuButton::Continue),
            ButtonState::Disabled
        );
        assert_eq!(
            menu.button_state(MainMenuButton::LoadGame),
            ButtonState::Disabled
        );

        // With saves, they should be enabled
        menu.set_save_availability(SaveAvailability::with_saves("Test", "Now"));
        assert_ne!(
            menu.button_state(MainMenuButton::Continue),
            ButtonState::Disabled
        );
        assert_ne!(
            menu.button_state(MainMenuButton::LoadGame),
            ButtonState::Disabled
        );
    }

    #[test]
    fn test_main_menu_skip_disabled_navigation() {
        let mut menu = MainMenu::with_defaults();
        // Continue (index 1) and LoadGame (index 2) are disabled

        menu.set_selected_index(0);
        menu.navigate(NavigationDirection::Down);

        // Should skip disabled buttons
        assert!(menu.selected_index() > 2 || menu.selected_index() == 0);
    }

    #[test]
    fn test_main_menu_click_disabled_no_action() {
        let mut menu = MainMenu::with_defaults();
        menu.click_button(MainMenuButton::Continue);

        let actions = menu.drain_actions();
        assert!(actions.is_empty());
    }

    #[test]
    fn test_main_menu_update() {
        let mut menu = MainMenu::with_defaults();
        assert_eq!(menu.animation_time(), 0.0);

        menu.update(0.1);
        assert!((menu.animation_time() - 0.1).abs() < f32::EPSILON);

        menu.update(0.05);
        assert!((menu.animation_time() - 0.15).abs() < f32::EPSILON);
    }

    #[test]
    fn test_main_menu_keyboard_nav_toggle() {
        let mut menu = MainMenu::with_defaults();
        assert!(menu.keyboard_nav_enabled());

        menu.set_keyboard_nav_enabled(false);
        assert!(!menu.keyboard_nav_enabled());
    }

    #[test]
    fn test_main_menu_has_actions() {
        let mut menu = MainMenu::with_defaults();
        assert!(!menu.has_actions());

        menu.click_button(MainMenuButton::Exit);
        assert!(menu.has_actions());

        menu.drain_actions();
        assert!(!menu.has_actions());
    }

    #[test]
    fn test_main_menu_config_serialization() {
        let config = MainMenuConfig::default();
        let json = serde_json::to_string(&config).unwrap();
        let parsed: MainMenuConfig = serde_json::from_str(&json).unwrap();
        assert_eq!(parsed.title, config.title);
        assert_eq!(parsed.button_width, config.button_width);
    }

    #[test]
    fn test_navigation_direction() {
        assert_ne!(NavigationDirection::Up, NavigationDirection::Down);
    }

    #[test]
    fn test_main_menu_action_equality() {
        assert_eq!(MainMenuAction::NewGame, MainMenuAction::NewGame);
        assert_ne!(MainMenuAction::NewGame, MainMenuAction::Exit);
    }
}
