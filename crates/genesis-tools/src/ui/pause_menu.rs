//! Pause Menu UI
//!
//! In-game pause menu that appears when ESC is pressed, providing
//! options to resume, save, load, access options, or quit.

use egui::{Color32, Ui};
use serde::{Deserialize, Serialize};

/// Pause menu button types
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default, Serialize, Deserialize)]
pub enum PauseMenuButton {
    /// Resume gameplay
    #[default]
    Resume,
    /// Save current game
    SaveGame,
    /// Load a saved game
    LoadGame,
    /// Open options menu
    Options,
    /// Quit to main menu
    QuitToMenu,
    /// Quit to desktop
    QuitToDesktop,
}

impl PauseMenuButton {
    /// Get all pause menu buttons in order
    pub fn all() -> &'static [Self] {
        &[
            Self::Resume,
            Self::SaveGame,
            Self::LoadGame,
            Self::Options,
            Self::QuitToMenu,
            Self::QuitToDesktop,
        ]
    }

    /// Get display text
    pub fn display_text(&self) -> &'static str {
        match self {
            Self::Resume => "Resume",
            Self::SaveGame => "Save Game",
            Self::LoadGame => "Load Game",
            Self::Options => "Options",
            Self::QuitToMenu => "Quit to Menu",
            Self::QuitToDesktop => "Quit to Desktop",
        }
    }

    /// Get button icon
    pub fn icon(&self) -> &'static str {
        match self {
            Self::Resume => "â–¶",
            Self::SaveGame => "ðŸ’¾",
            Self::LoadGame => "ðŸ“‚",
            Self::Options => "âš™",
            Self::QuitToMenu => "ðŸ ",
            Self::QuitToDesktop => "ðŸšª",
        }
    }

    /// Check if this is a dangerous action requiring confirmation
    pub fn requires_confirmation(&self) -> bool {
        matches!(self, Self::QuitToMenu | Self::QuitToDesktop)
    }
}

/// Actions generated by the pause menu
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum PauseMenuAction {
    /// Resume the game
    Resume,
    /// Open save game menu
    OpenSaveMenu,
    /// Open load game menu
    OpenLoadMenu,
    /// Open options menu
    OpenOptions,
    /// Quit to main menu
    QuitToMenu,
    /// Quit to desktop
    QuitToDesktop,
    /// Toggle pause menu visibility
    Toggle,
    /// Navigate up
    NavigateUp,
    /// Navigate down
    NavigateDown,
    /// Confirm selection
    Confirm,
    /// Cancel/close menu
    Cancel,
}

/// Overlay style for the pause menu
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default, Serialize, Deserialize)]
pub enum OverlayStyle {
    /// Semi-transparent dark overlay
    #[default]
    Dark,
    /// Semi-transparent blur effect
    Blur,
    /// Fully opaque background
    Solid,
    /// No overlay, just the menu panel
    None,
}

impl OverlayStyle {
    /// Get all overlay styles
    pub fn all() -> &'static [Self] {
        &[Self::Dark, Self::Blur, Self::Solid, Self::None]
    }

    /// Get display name
    pub fn display_name(&self) -> &'static str {
        match self {
            Self::Dark => "Dark",
            Self::Blur => "Blur",
            Self::Solid => "Solid",
            Self::None => "None",
        }
    }

    /// Get overlay color
    pub fn overlay_color(&self) -> Color32 {
        match self {
            Self::Dark => Color32::from_rgba_unmultiplied(0, 0, 0, 180),
            Self::Blur => Color32::from_rgba_unmultiplied(20, 20, 30, 150),
            Self::Solid => Color32::from_rgba_unmultiplied(20, 20, 30, 255),
            Self::None => Color32::TRANSPARENT,
        }
    }
}

/// Configuration for pause menu appearance
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PauseMenuConfig {
    /// Title text
    pub title: String,
    /// Overlay style
    pub overlay_style: OverlayStyle,
    /// Panel background color
    pub panel_color: [u8; 4],
    /// Panel border color
    pub border_color: [u8; 4],
    /// Button width
    pub button_width: f32,
    /// Button height
    pub button_height: f32,
    /// Button spacing
    pub button_spacing: f32,
    /// Show button icons
    pub show_icons: bool,
    /// Show game time in menu
    pub show_game_time: bool,
    /// Pause game while menu is open
    pub pause_game: bool,
}

impl Default for PauseMenuConfig {
    fn default() -> Self {
        Self {
            title: String::from("Game Paused"),
            overlay_style: OverlayStyle::Dark,
            panel_color: [30, 30, 40, 240],
            border_color: [80, 80, 100, 255],
            button_width: 180.0,
            button_height: 44.0,
            button_spacing: 8.0,
            show_icons: true,
            show_game_time: true,
            pause_game: true,
        }
    }
}

/// Button visual state
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum PauseButtonState {
    /// Normal state
    #[default]
    Normal,
    /// Hovered/selected
    Hovered,
    /// Pressed
    Pressed,
    /// Disabled
    Disabled,
}

impl PauseButtonState {
    /// Get background color
    pub fn background_color(&self) -> Color32 {
        match self {
            Self::Normal => Color32::from_rgba_unmultiplied(50, 50, 60, 200),
            Self::Hovered => Color32::from_rgba_unmultiplied(70, 70, 90, 230),
            Self::Pressed => Color32::from_rgba_unmultiplied(90, 90, 110, 255),
            Self::Disabled => Color32::from_rgba_unmultiplied(40, 40, 45, 150),
        }
    }

    /// Get text color
    pub fn text_color(&self) -> Color32 {
        match self {
            Self::Normal => Color32::from_gray(180),
            Self::Hovered | Self::Pressed => Color32::from_gray(255),
            Self::Disabled => Color32::from_gray(90),
        }
    }

    /// Check if interactive
    pub fn is_interactive(&self) -> bool {
        !matches!(self, Self::Disabled)
    }
}

/// Game state information for display
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct GameStateInfo {
    /// Current game time (formatted)
    pub game_time: String,
    /// Player name
    pub player_name: String,
    /// Current location
    pub location: String,
    /// Whether save is allowed
    pub can_save: bool,
    /// Reason save is not allowed
    pub save_disabled_reason: Option<String>,
}

impl GameStateInfo {
    /// Create default game state
    pub fn new() -> Self {
        Self::default()
    }

    /// Set game time
    pub fn with_time(mut self, time: impl Into<String>) -> Self {
        self.game_time = time.into();
        self
    }

    /// Set player name
    pub fn with_player(mut self, name: impl Into<String>) -> Self {
        self.player_name = name.into();
        self
    }

    /// Set location
    pub fn with_location(mut self, location: impl Into<String>) -> Self {
        self.location = location.into();
        self
    }

    /// Set save availability
    pub fn with_save_available(mut self, can_save: bool, reason: Option<String>) -> Self {
        self.can_save = can_save;
        self.save_disabled_reason = reason;
        self
    }
}

/// Confirmation dialog state
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum ConfirmationDialog {
    /// No dialog shown
    None,
    /// Confirming quit to menu
    QuitToMenu,
    /// Confirming quit to desktop
    QuitToDesktop,
}

impl Default for ConfirmationDialog {
    fn default() -> Self {
        Self::None
    }
}

impl ConfirmationDialog {
    /// Check if dialog is showing
    pub fn is_showing(&self) -> bool {
        !matches!(self, Self::None)
    }

    /// Get dialog title
    pub fn title(&self) -> &'static str {
        match self {
            Self::None => "",
            Self::QuitToMenu => "Quit to Menu?",
            Self::QuitToDesktop => "Quit to Desktop?",
        }
    }

    /// Get dialog message
    pub fn message(&self) -> &'static str {
        match self {
            Self::None => "",
            Self::QuitToMenu | Self::QuitToDesktop => "Any unsaved progress will be lost.",
        }
    }
}

/// Pause menu state
#[derive(Debug, Clone)]
pub struct PauseMenu {
    /// Configuration
    config: PauseMenuConfig,
    /// Whether menu is visible
    visible: bool,
    /// Currently selected button index
    selected_index: usize,
    /// Button states
    button_states: Vec<PauseButtonState>,
    /// Game state info
    game_state: GameStateInfo,
    /// Current confirmation dialog
    confirmation: ConfirmationDialog,
    /// Pending actions
    actions: Vec<PauseMenuAction>,
    /// Whether ESC should close
    esc_closes: bool,
}

impl PauseMenu {
    /// Create a new pause menu
    pub fn new(config: PauseMenuConfig) -> Self {
        let button_count = PauseMenuButton::all().len();
        Self {
            config,
            visible: false,
            selected_index: 0,
            button_states: vec![PauseButtonState::Normal; button_count],
            game_state: GameStateInfo::new(),
            confirmation: ConfirmationDialog::None,
            actions: Vec::new(),
            esc_closes: true,
        }
    }

    /// Create with default configuration
    pub fn with_defaults() -> Self {
        Self::new(PauseMenuConfig::default())
    }

    /// Get configuration
    pub fn config(&self) -> &PauseMenuConfig {
        &self.config
    }

    /// Get mutable configuration
    pub fn config_mut(&mut self) -> &mut PauseMenuConfig {
        &mut self.config
    }

    /// Check if visible
    pub fn is_visible(&self) -> bool {
        self.visible
    }

    /// Set visibility
    pub fn set_visible(&mut self, visible: bool) {
        self.visible = visible;
        if visible {
            self.selected_index = 0;
            self.confirmation = ConfirmationDialog::None;
            self.update_button_states();
        }
    }

    /// Show the menu
    pub fn show(&mut self) {
        self.set_visible(true);
    }

    /// Hide the menu
    pub fn hide(&mut self) {
        self.set_visible(false);
    }

    /// Toggle visibility
    pub fn toggle(&mut self) {
        if self.visible {
            // If showing confirmation, close that first
            if self.confirmation.is_showing() {
                self.confirmation = ConfirmationDialog::None;
            } else if self.esc_closes {
                self.hide();
                self.actions.push(PauseMenuAction::Resume);
            }
        } else {
            self.show();
        }
    }

    /// Handle ESC key press
    pub fn handle_escape(&mut self) {
        self.toggle();
    }

    /// Set game state info
    pub fn set_game_state(&mut self, state: GameStateInfo) {
        self.game_state = state;
        self.update_button_states();
    }

    /// Get game state
    pub fn game_state(&self) -> &GameStateInfo {
        &self.game_state
    }

    /// Get selected button
    pub fn selected_button(&self) -> PauseMenuButton {
        PauseMenuButton::all()[self.selected_index]
    }

    /// Get selected index
    pub fn selected_index(&self) -> usize {
        self.selected_index
    }

    /// Set selected index
    pub fn set_selected_index(&mut self, index: usize) {
        let max = PauseMenuButton::all().len().saturating_sub(1);
        self.selected_index = index.min(max);
        self.update_button_states();
    }

    /// Navigate up
    pub fn navigate_up(&mut self) {
        if self.confirmation.is_showing() {
            return;
        }

        let len = PauseMenuButton::all().len();
        let mut new_index = if self.selected_index == 0 {
            len - 1
        } else {
            self.selected_index - 1
        };

        // Skip disabled
        let start = new_index;
        while self.button_states[new_index] == PauseButtonState::Disabled {
            new_index = if new_index == 0 {
                len - 1
            } else {
                new_index - 1
            };
            if new_index == start {
                break;
            }
        }

        self.selected_index = new_index;
        self.update_button_states();
    }

    /// Navigate down
    pub fn navigate_down(&mut self) {
        if self.confirmation.is_showing() {
            return;
        }

        let len = PauseMenuButton::all().len();
        let mut new_index = (self.selected_index + 1) % len;

        // Skip disabled
        let start = new_index;
        while self.button_states[new_index] == PauseButtonState::Disabled {
            new_index = (new_index + 1) % len;
            if new_index == start {
                break;
            }
        }

        self.selected_index = new_index;
        self.update_button_states();
    }

    /// Confirm current selection
    pub fn confirm_selection(&mut self) {
        if self.confirmation.is_showing() {
            // Confirm the dialog
            match &self.confirmation {
                ConfirmationDialog::QuitToMenu => {
                    self.actions.push(PauseMenuAction::QuitToMenu);
                    self.hide();
                },
                ConfirmationDialog::QuitToDesktop => {
                    self.actions.push(PauseMenuAction::QuitToDesktop);
                },
                ConfirmationDialog::None => {},
            }
            self.confirmation = ConfirmationDialog::None;
            return;
        }

        let button = self.selected_button();
        if self.button_states[self.selected_index] == PauseButtonState::Disabled {
            return;
        }

        // Handle confirmation-required actions
        if button.requires_confirmation() {
            self.confirmation = match button {
                PauseMenuButton::QuitToMenu => ConfirmationDialog::QuitToMenu,
                PauseMenuButton::QuitToDesktop => ConfirmationDialog::QuitToDesktop,
                _ => ConfirmationDialog::None,
            };
            return;
        }

        let action = match button {
            PauseMenuButton::Resume => {
                self.hide();
                PauseMenuAction::Resume
            },
            PauseMenuButton::SaveGame => PauseMenuAction::OpenSaveMenu,
            PauseMenuButton::LoadGame => PauseMenuAction::OpenLoadMenu,
            PauseMenuButton::Options => PauseMenuAction::OpenOptions,
            PauseMenuButton::QuitToMenu => PauseMenuAction::QuitToMenu,
            PauseMenuButton::QuitToDesktop => PauseMenuAction::QuitToDesktop,
        };

        self.actions.push(action);
    }

    /// Cancel current action (close dialog or menu)
    pub fn cancel(&mut self) {
        if self.confirmation.is_showing() {
            self.confirmation = ConfirmationDialog::None;
        } else {
            self.hide();
            self.actions.push(PauseMenuAction::Resume);
        }
    }

    /// Click a specific button
    pub fn click_button(&mut self, button: PauseMenuButton) {
        let index = PauseMenuButton::all()
            .iter()
            .position(|b| *b == button)
            .unwrap_or(0);

        if self.button_states[index] == PauseButtonState::Disabled {
            return;
        }

        self.selected_index = index;
        self.confirm_selection();
    }

    /// Get button state
    pub fn button_state(&self, button: PauseMenuButton) -> PauseButtonState {
        let index = PauseMenuButton::all()
            .iter()
            .position(|b| *b == button)
            .unwrap_or(0);
        self.button_states[index]
    }

    /// Check if confirmation dialog is showing
    pub fn is_confirmation_showing(&self) -> bool {
        self.confirmation.is_showing()
    }

    /// Get current confirmation dialog
    pub fn confirmation_dialog(&self) -> &ConfirmationDialog {
        &self.confirmation
    }

    /// Set whether ESC closes the menu
    pub fn set_esc_closes(&mut self, closes: bool) {
        self.esc_closes = closes;
    }

    /// Drain pending actions
    pub fn drain_actions(&mut self) -> Vec<PauseMenuAction> {
        std::mem::take(&mut self.actions)
    }

    /// Check if has pending actions
    pub fn has_actions(&self) -> bool {
        !self.actions.is_empty()
    }

    /// Update button states
    fn update_button_states(&mut self) {
        let buttons = PauseMenuButton::all();
        for (i, button) in buttons.iter().enumerate() {
            let state = if self.is_button_disabled(*button) {
                PauseButtonState::Disabled
            } else if i == self.selected_index {
                PauseButtonState::Hovered
            } else {
                PauseButtonState::Normal
            };
            self.button_states[i] = state;
        }
    }

    /// Check if button should be disabled
    fn is_button_disabled(&self, button: PauseMenuButton) -> bool {
        match button {
            PauseMenuButton::SaveGame => !self.game_state.can_save,
            _ => false,
        }
    }

    /// Render the pause menu
    pub fn render(&mut self, ui: &mut Ui) {
        if !self.visible {
            return;
        }

        // Render overlay
        let overlay_color = self.config.overlay_style.overlay_color();
        if overlay_color.a() > 0 {
            let screen_rect = ui.ctx().screen_rect();
            ui.painter().rect_filled(screen_rect, 0.0, overlay_color);
        }

        // Render panel
        let panel_color = Color32::from_rgba_unmultiplied(
            self.config.panel_color[0],
            self.config.panel_color[1],
            self.config.panel_color[2],
            self.config.panel_color[3],
        );
        let border_color = Color32::from_rgba_unmultiplied(
            self.config.border_color[0],
            self.config.border_color[1],
            self.config.border_color[2],
            self.config.border_color[3],
        );

        egui::Area::new(egui::Id::new("pause_menu"))
            .anchor(egui::Align2::CENTER_CENTER, egui::vec2(0.0, 0.0))
            .show(ui.ctx(), |ui| {
                egui::Frame::none()
                    .fill(panel_color)
                    .stroke(egui::Stroke::new(2.0, border_color))
                    .rounding(8.0)
                    .inner_margin(24.0)
                    .show(ui, |ui| {
                        if self.confirmation.is_showing() {
                            self.render_confirmation(ui);
                        } else {
                            self.render_menu(ui);
                        }
                    });
            });
    }

    fn render_menu(&mut self, ui: &mut Ui) {
        ui.vertical_centered(|ui| {
            // Title
            ui.label(
                egui::RichText::new(&self.config.title)
                    .size(28.0)
                    .color(Color32::from_gray(220))
                    .strong(),
            );

            // Game info
            if self.config.show_game_time && !self.game_state.game_time.is_empty() {
                ui.add_space(8.0);
                ui.label(
                    egui::RichText::new(&self.game_state.game_time)
                        .size(14.0)
                        .color(Color32::from_gray(140)),
                );
            }

            ui.add_space(20.0);

            // Buttons
            self.render_buttons(ui);
        });
    }

    fn render_buttons(&mut self, ui: &mut Ui) {
        let buttons = PauseMenuButton::all();

        for (i, button) in buttons.iter().enumerate() {
            let state = self.button_states[i];
            let button_size = egui::vec2(self.config.button_width, self.config.button_height);
            let (rect, response) = ui.allocate_exact_size(button_size, egui::Sense::click());

            if state.is_interactive() {
                if response.hovered() && self.selected_index != i {
                    self.selected_index = i;
                    self.update_button_states();
                }

                if response.clicked() {
                    self.click_button(*button);
                }
            }

            let current_state = self.button_states[i];
            ui.painter()
                .rect_filled(rect, 4.0, current_state.background_color());

            let mut text = String::new();
            if self.config.show_icons {
                text.push_str(button.icon());
                text.push(' ');
            }
            text.push_str(button.display_text());

            ui.painter().text(
                rect.center(),
                egui::Align2::CENTER_CENTER,
                text,
                egui::FontId::proportional(16.0),
                current_state.text_color(),
            );

            // Show disabled reason
            if *button == PauseMenuButton::SaveGame && state == PauseButtonState::Disabled {
                if let Some(ref reason) = self.game_state.save_disabled_reason {
                    let info_rect =
                        rect.translate(egui::vec2(0.0, self.config.button_height * 0.4));
                    ui.painter().text(
                        info_rect.center(),
                        egui::Align2::CENTER_TOP,
                        reason,
                        egui::FontId::proportional(11.0),
                        Color32::from_gray(100),
                    );
                }
            }

            ui.add_space(self.config.button_spacing);
        }
    }

    fn render_confirmation(&mut self, ui: &mut Ui) {
        ui.vertical_centered(|ui| {
            ui.label(
                egui::RichText::new(self.confirmation.title())
                    .size(24.0)
                    .color(Color32::from_rgb(200, 150, 100))
                    .strong(),
            );

            ui.add_space(16.0);

            ui.label(
                egui::RichText::new(self.confirmation.message())
                    .size(14.0)
                    .color(Color32::from_gray(180)),
            );

            ui.add_space(24.0);

            ui.horizontal(|ui| {
                if ui.button("Cancel").clicked() {
                    self.confirmation = ConfirmationDialog::None;
                }
                ui.add_space(16.0);
                if ui
                    .button(egui::RichText::new("Confirm").color(Color32::from_rgb(200, 100, 100)))
                    .clicked()
                {
                    self.confirm_selection();
                }
            });
        });
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_pause_menu_button_all() {
        let buttons = PauseMenuButton::all();
        assert_eq!(buttons.len(), 6);
        assert_eq!(buttons[0], PauseMenuButton::Resume);
        assert_eq!(buttons[5], PauseMenuButton::QuitToDesktop);
    }

    #[test]
    fn test_pause_menu_button_display_text() {
        assert_eq!(PauseMenuButton::Resume.display_text(), "Resume");
        assert_eq!(PauseMenuButton::SaveGame.display_text(), "Save Game");
        assert_eq!(
            PauseMenuButton::QuitToDesktop.display_text(),
            "Quit to Desktop"
        );
    }

    #[test]
    fn test_pause_menu_button_icon() {
        assert_eq!(PauseMenuButton::Resume.icon(), "â–¶");
        assert_eq!(PauseMenuButton::SaveGame.icon(), "ðŸ’¾");
    }

    #[test]
    fn test_pause_menu_button_requires_confirmation() {
        assert!(!PauseMenuButton::Resume.requires_confirmation());
        assert!(!PauseMenuButton::SaveGame.requires_confirmation());
        assert!(PauseMenuButton::QuitToMenu.requires_confirmation());
        assert!(PauseMenuButton::QuitToDesktop.requires_confirmation());
    }

    #[test]
    fn test_overlay_style_all() {
        let styles = OverlayStyle::all();
        assert_eq!(styles.len(), 4);
    }

    #[test]
    fn test_overlay_style_display_name() {
        assert_eq!(OverlayStyle::Dark.display_name(), "Dark");
        assert_eq!(OverlayStyle::Blur.display_name(), "Blur");
    }

    #[test]
    fn test_overlay_style_color() {
        assert!(OverlayStyle::Dark.overlay_color().a() > 0);
        assert_eq!(OverlayStyle::None.overlay_color(), Color32::TRANSPARENT);
    }

    #[test]
    fn test_pause_menu_config_defaults() {
        let config = PauseMenuConfig::default();
        assert_eq!(config.title, "Game Paused");
        assert!(config.button_width > 0.0);
        assert!(config.pause_game);
    }

    #[test]
    fn test_pause_button_state_is_interactive() {
        assert!(PauseButtonState::Normal.is_interactive());
        assert!(PauseButtonState::Hovered.is_interactive());
        assert!(!PauseButtonState::Disabled.is_interactive());
    }

    #[test]
    fn test_pause_button_state_colors() {
        assert_ne!(
            PauseButtonState::Normal.background_color(),
            PauseButtonState::Hovered.background_color()
        );
    }

    #[test]
    fn test_game_state_info_builders() {
        let state = GameStateInfo::new()
            .with_time("Day 5, 14:30")
            .with_player("Hero")
            .with_location("Forest")
            .with_save_available(true, None);

        assert_eq!(state.game_time, "Day 5, 14:30");
        assert_eq!(state.player_name, "Hero");
        assert_eq!(state.location, "Forest");
        assert!(state.can_save);
    }

    #[test]
    fn test_game_state_info_save_disabled() {
        let state =
            GameStateInfo::new().with_save_available(false, Some(String::from("In combat")));

        assert!(!state.can_save);
        assert_eq!(state.save_disabled_reason, Some(String::from("In combat")));
    }

    #[test]
    fn test_confirmation_dialog_is_showing() {
        assert!(!ConfirmationDialog::None.is_showing());
        assert!(ConfirmationDialog::QuitToMenu.is_showing());
        assert!(ConfirmationDialog::QuitToDesktop.is_showing());
    }

    #[test]
    fn test_confirmation_dialog_title_message() {
        assert_eq!(ConfirmationDialog::QuitToMenu.title(), "Quit to Menu?");
        assert!(!ConfirmationDialog::QuitToMenu.message().is_empty());
    }

    #[test]
    fn test_pause_menu_new() {
        let menu = PauseMenu::with_defaults();
        assert!(!menu.is_visible());
        assert_eq!(menu.selected_index(), 0);
    }

    #[test]
    fn test_pause_menu_visibility() {
        let mut menu = PauseMenu::with_defaults();
        assert!(!menu.is_visible());

        menu.show();
        assert!(menu.is_visible());

        menu.hide();
        assert!(!menu.is_visible());
    }

    #[test]
    fn test_pause_menu_toggle() {
        let mut menu = PauseMenu::with_defaults();

        menu.toggle();
        assert!(menu.is_visible());

        menu.toggle();
        assert!(!menu.is_visible());
    }

    #[test]
    fn test_pause_menu_handle_escape() {
        let mut menu = PauseMenu::with_defaults();

        menu.handle_escape();
        assert!(menu.is_visible());

        menu.handle_escape();
        assert!(!menu.is_visible());
    }

    #[test]
    fn test_pause_menu_navigate() {
        let mut menu = PauseMenu::with_defaults();
        menu.show();
        menu.set_game_state(GameStateInfo::new().with_save_available(true, None));

        assert_eq!(menu.selected_index(), 0);

        menu.navigate_down();
        assert_eq!(menu.selected_index(), 1);

        menu.navigate_up();
        assert_eq!(menu.selected_index(), 0);
    }

    #[test]
    fn test_pause_menu_navigate_wrap() {
        let mut menu = PauseMenu::with_defaults();
        menu.show();
        menu.set_game_state(GameStateInfo::new().with_save_available(true, None));

        menu.navigate_up();
        assert_eq!(menu.selected_index(), 5);

        menu.navigate_down();
        assert_eq!(menu.selected_index(), 0);
    }

    #[test]
    fn test_pause_menu_confirm_resume() {
        let mut menu = PauseMenu::with_defaults();
        menu.show();

        menu.confirm_selection();
        assert!(!menu.is_visible());

        let actions = menu.drain_actions();
        assert_eq!(actions.len(), 1);
        assert_eq!(actions[0], PauseMenuAction::Resume);
    }

    #[test]
    fn test_pause_menu_quit_confirmation() {
        let mut menu = PauseMenu::with_defaults();
        menu.show();
        menu.set_game_state(GameStateInfo::new().with_save_available(true, None));

        menu.click_button(PauseMenuButton::QuitToMenu);

        // Should show confirmation, not quit immediately
        assert!(menu.is_confirmation_showing());
        assert!(menu.drain_actions().is_empty());

        // Confirm the dialog
        menu.confirm_selection();
        let actions = menu.drain_actions();
        assert_eq!(actions.len(), 1);
        assert_eq!(actions[0], PauseMenuAction::QuitToMenu);
    }

    #[test]
    fn test_pause_menu_cancel_confirmation() {
        let mut menu = PauseMenu::with_defaults();
        menu.show();
        menu.set_game_state(GameStateInfo::new().with_save_available(true, None));

        menu.click_button(PauseMenuButton::QuitToMenu);
        assert!(menu.is_confirmation_showing());

        menu.cancel();
        assert!(!menu.is_confirmation_showing());
        assert!(menu.is_visible());
    }

    #[test]
    fn test_pause_menu_save_disabled() {
        let mut menu = PauseMenu::with_defaults();
        menu.show();
        menu.set_game_state(GameStateInfo::new().with_save_available(false, None));

        assert_eq!(
            menu.button_state(PauseMenuButton::SaveGame),
            PauseButtonState::Disabled
        );
    }

    #[test]
    fn test_pause_menu_click_disabled_no_action() {
        let mut menu = PauseMenu::with_defaults();
        menu.show();
        menu.set_game_state(GameStateInfo::new().with_save_available(false, None));

        menu.click_button(PauseMenuButton::SaveGame);
        assert!(menu.drain_actions().is_empty());
    }

    #[test]
    fn test_pause_menu_esc_closes_confirmation_first() {
        let mut menu = PauseMenu::with_defaults();
        menu.show();
        menu.set_game_state(GameStateInfo::new().with_save_available(true, None));

        menu.click_button(PauseMenuButton::QuitToMenu);
        assert!(menu.is_confirmation_showing());

        // ESC should close confirmation, not the menu
        menu.toggle();
        assert!(!menu.is_confirmation_showing());
        assert!(menu.is_visible());
    }

    #[test]
    fn test_pause_menu_action_equality() {
        assert_eq!(PauseMenuAction::Resume, PauseMenuAction::Resume);
        assert_ne!(PauseMenuAction::Resume, PauseMenuAction::QuitToMenu);
    }

    #[test]
    fn test_pause_menu_has_actions() {
        let mut menu = PauseMenu::with_defaults();
        assert!(!menu.has_actions());

        menu.show();
        menu.click_button(PauseMenuButton::Options);
        assert!(menu.has_actions());
    }

    #[test]
    fn test_pause_menu_config_serialization() {
        let config = PauseMenuConfig::default();
        let json = serde_json::to_string(&config).unwrap();
        let parsed: PauseMenuConfig = serde_json::from_str(&json).unwrap();
        assert_eq!(parsed.title, config.title);
    }

    #[test]
    fn test_game_state_info_serialization() {
        let state = GameStateInfo::new().with_time("Day 1").with_player("Test");
        let json = serde_json::to_string(&state).unwrap();
        let parsed: GameStateInfo = serde_json::from_str(&json).unwrap();
        assert_eq!(parsed.game_time, state.game_time);
    }
}
