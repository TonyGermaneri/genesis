//! Event buffer system for GPU → CPU communication.
//!
//! This module provides the `Event` type and `EventBuffer` for reading
//! GPU-generated events back to the CPU after simulation.
//!
//! Events represent notifications from the GPU about significant cell
//! state changes, such as cells being destroyed, catching fire, or
//! undergoing other state transitions.

use bytemuck::{Pod, Zeroable};
use parking_lot::Mutex;
use std::sync::Arc;
use tracing::{info, warn};
use wgpu::{Buffer, BufferUsages, Device, Queue};

/// Maximum number of events that can be generated per frame.
pub const MAX_EVENTS: usize = 1024;

/// Event types generated by the GPU.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
#[repr(u8)]
pub enum EventType {
    /// Cell was destroyed/cleared
    Destroyed = 0,
    /// Cell state changed (material, flags, etc.)
    StateChange = 1,
    /// Cell caught fire
    Ignited = 2,
    /// Cell fire was extinguished
    Extinguished = 3,
    /// Cell temperature changed significantly
    TemperatureChange = 4,
    /// Cell collision occurred
    Collision = 5,
    /// Cell was created/spawned
    Created = 6,
}

impl From<u8> for EventType {
    fn from(value: u8) -> Self {
        match value {
            0 => EventType::Destroyed,
            2 => EventType::Ignited,
            3 => EventType::Extinguished,
            4 => EventType::TemperatureChange,
            5 => EventType::Collision,
            6 => EventType::Created,
            _ => EventType::StateChange, // 1 and fallback
        }
    }
}

/// A single event generated by the GPU.
///
/// Events represent GPU-side notifications about cell state changes.
/// The CPU can subscribe to these events for gameplay logic, audio, UI, etc.
///
/// # Layout (16 bytes, GPU-aligned)
/// ```text
/// ┌────────────┬────────────┬─────────────┬─────────────────────────┐
/// │ x (u32)    │ y (u32)    │ event_type  │ payload (7 bytes)       │
/// └────────────┴────────────┴─────────────┴─────────────────────────┘
/// ```
#[derive(Debug, Clone, Copy, Default, Pod, Zeroable)]
#[repr(C)]
pub struct Event {
    /// X coordinate of source cell
    pub x: u32,
    /// Y coordinate of source cell
    pub y: u32,
    /// Event type (see EventType)
    pub event_type: u8,
    /// Event-specific payload data
    pub payload: [u8; 7],
}

impl Event {
    /// Creates a new event at the given position with the specified type.
    #[must_use]
    pub const fn new(x: u32, y: u32, event_type: EventType) -> Self {
        Self {
            x,
            y,
            event_type: event_type as u8,
            payload: [0; 7],
        }
    }

    /// Returns the event type.
    #[must_use]
    pub fn event_type(&self) -> EventType {
        EventType::from(self.event_type)
    }

    /// Extracts the old material ID from StateChange payload.
    #[must_use]
    pub fn old_material(&self) -> u16 {
        u16::from_le_bytes([self.payload[0], self.payload[1]])
    }

    /// Extracts the new material ID from StateChange payload.
    #[must_use]
    pub fn new_material(&self) -> u16 {
        u16::from_le_bytes([self.payload[2], self.payload[3]])
    }

    /// Extracts temperature from TemperatureChange payload.
    #[must_use]
    pub fn temperature(&self) -> u8 {
        self.payload[0]
    }

    /// Checks if this event has valid data (non-zero position or type).
    #[must_use]
    pub fn is_valid(&self) -> bool {
        self.x != 0 || self.y != 0 || self.event_type != 0
    }
}

/// Event buffer header for GPU communication.
///
/// This header is stored at the start of the GPU buffer and contains
/// the event count written by the GPU.
#[derive(Debug, Clone, Copy, Pod, Zeroable)]
#[repr(C)]
pub struct EventBufferHeader {
    /// Number of events written by GPU
    pub count: u32,
    /// Maximum capacity
    pub capacity: u32,
    /// Reserved for future use
    _reserved: [u32; 2],
}

impl Default for EventBufferHeader {
    fn default() -> Self {
        Self {
            count: 0,
            capacity: MAX_EVENTS as u32,
            _reserved: [0; 2],
        }
    }
}

/// Async readback state for event buffer.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ReadbackState {
    /// No readback in progress
    Idle,
    /// Readback has been requested, waiting for GPU
    Pending,
    /// Readback completed, data available
    Ready,
    /// Readback failed
    Failed,
}

/// CPU-side event buffer that reads GPU-generated events.
///
/// The `EventBuffer` provides async readback of events generated by the
/// GPU simulation. Events are collected into a staging buffer and then
/// mapped for CPU access.
///
/// # Example
///
/// ```ignore
/// let mut event_buffer = EventBuffer::new(&device);
///
/// // After simulation dispatch, request readback
/// event_buffer.request_readback(&device, &queue);
///
/// // Poll for completion (or use async)
/// if event_buffer.poll_readback(&device) {
///     let events = event_buffer.drain_events();
///     for event in events {
///         match event.event_type() {
///             EventType::Destroyed => { /* handle destruction */ }
///             EventType::Ignited => { /* play fire sound */ }
///             _ => {}
///         }
///     }
/// }
/// ```
pub struct EventBuffer {
    /// GPU storage buffer for events (written by GPU)
    gpu_buffer: Buffer,
    /// Staging buffer for CPU readback
    staging_buffer: Buffer,
    /// Received events (after readback)
    events: Vec<Event>,
    /// Current readback state
    state: Arc<Mutex<ReadbackState>>,
    /// Buffer size in bytes
    buffer_size: u64,
}

impl EventBuffer {
    /// Creates a new event buffer.
    ///
    /// # Arguments
    /// * `device` - The wgpu device to create buffers on
    pub fn new(device: &Device) -> Self {
        info!("Creating event buffer (capacity: {})", MAX_EVENTS);

        // Calculate buffer size: header + events
        let header_size = std::mem::size_of::<EventBufferHeader>();
        let events_size = MAX_EVENTS * std::mem::size_of::<Event>();
        let total_size = (header_size + events_size) as u64;

        // GPU buffer - written by compute shader
        let gpu_buffer = device.create_buffer(&wgpu::BufferDescriptor {
            label: Some("Event GPU Buffer"),
            size: total_size,
            usage: BufferUsages::STORAGE | BufferUsages::COPY_SRC,
            mapped_at_creation: false,
        });

        // Staging buffer - for CPU readback
        let staging_buffer = device.create_buffer(&wgpu::BufferDescriptor {
            label: Some("Event Staging Buffer"),
            size: total_size,
            usage: BufferUsages::COPY_DST | BufferUsages::MAP_READ,
            mapped_at_creation: false,
        });

        Self {
            gpu_buffer,
            staging_buffer,
            events: Vec::with_capacity(MAX_EVENTS),
            state: Arc::new(Mutex::new(ReadbackState::Idle)),
            buffer_size: total_size,
        }
    }

    /// Requests async readback of events from the GPU.
    ///
    /// This copies the GPU buffer to the staging buffer and initiates
    /// an async map operation. Use `poll_readback` to check completion.
    pub fn request_readback(&mut self, encoder: &mut wgpu::CommandEncoder) {
        let mut state = self.state.lock();
        if *state != ReadbackState::Idle {
            warn!("Event readback already in progress, skipping request");
            return;
        }

        // Copy GPU buffer to staging buffer
        encoder.copy_buffer_to_buffer(
            &self.gpu_buffer,
            0,
            &self.staging_buffer,
            0,
            self.buffer_size,
        );

        *state = ReadbackState::Pending;
    }

    /// Polls for readback completion and processes events.
    ///
    /// Returns `true` if events are ready to be consumed via `drain_events`.
    pub fn poll_readback(&mut self, device: &Device) -> bool {
        let state_value = *self.state.lock();

        match state_value {
            ReadbackState::Ready => true,
            ReadbackState::Idle | ReadbackState::Failed => false,
            ReadbackState::Pending => {
                // Try to map the staging buffer
                let state_clone = self.state.clone();
                let slice = self.staging_buffer.slice(..);

                slice.map_async(wgpu::MapMode::Read, move |result| {
                    let mut state = state_clone.lock();
                    match result {
                        Ok(()) => *state = ReadbackState::Ready,
                        Err(_) => *state = ReadbackState::Failed,
                    }
                });

                // Poll the device to process the map request
                device.poll(wgpu::Maintain::Poll);

                // Check if mapping completed
                *self.state.lock() == ReadbackState::Ready
            },
        }
    }

    /// Processes the mapped buffer and extracts events.
    ///
    /// Call this after `poll_readback` returns `true`.
    pub fn process_events(&mut self) {
        if *self.state.lock() != ReadbackState::Ready {
            return;
        }

        self.events.clear();

        // Read the mapped data
        {
            let slice = self.staging_buffer.slice(..);
            let data = slice.get_mapped_range();

            // Parse header
            let header_size = std::mem::size_of::<EventBufferHeader>();
            let header: EventBufferHeader = *bytemuck::from_bytes(&data[..header_size]);

            // Parse events
            let event_count = (header.count as usize).min(MAX_EVENTS);
            if event_count > 0 {
                let events_data = &data[header_size..];
                let events: &[Event] = bytemuck::cast_slice(
                    &events_data[..event_count * std::mem::size_of::<Event>()],
                );
                self.events.extend_from_slice(events);
            }
        }

        // Unmap the buffer
        self.staging_buffer.unmap();

        // Reset state
        *self.state.lock() = ReadbackState::Idle;
    }

    /// Drains all received events.
    ///
    /// Returns the events and clears the internal buffer.
    pub fn drain_events(&mut self) -> Vec<Event> {
        std::mem::take(&mut self.events)
    }

    /// Returns a reference to the received events.
    #[must_use]
    pub fn events(&self) -> &[Event] {
        &self.events
    }

    /// Returns the number of received events.
    #[must_use]
    pub fn event_count(&self) -> usize {
        self.events.len()
    }

    /// Returns the GPU buffer for binding.
    #[must_use]
    pub fn gpu_buffer(&self) -> &Buffer {
        &self.gpu_buffer
    }

    /// Returns the current readback state.
    #[must_use]
    pub fn state(&self) -> ReadbackState {
        *self.state.lock()
    }

    /// Clears the GPU event buffer.
    ///
    /// Call this at the start of each frame to reset the event count.
    pub fn clear_gpu_buffer(&self, queue: &Queue) {
        let header = EventBufferHeader::default();
        queue.write_buffer(&self.gpu_buffer, 0, bytemuck::bytes_of(&header));
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_event_size() {
        // Ensure event is properly aligned for GPU
        assert_eq!(std::mem::size_of::<Event>(), 16);
    }

    #[test]
    fn test_event_header_size() {
        // Ensure header is properly aligned
        assert_eq!(std::mem::size_of::<EventBufferHeader>(), 16);
    }

    #[test]
    fn test_event_type_from_u8() {
        assert_eq!(EventType::from(0), EventType::Destroyed);
        assert_eq!(EventType::from(1), EventType::StateChange);
        assert_eq!(EventType::from(2), EventType::Ignited);
        assert_eq!(EventType::from(255), EventType::StateChange); // Fallback
    }

    #[test]
    fn test_event_is_valid() {
        let empty = Event::default();
        assert!(!empty.is_valid());

        let valid = Event::new(10, 20, EventType::Destroyed);
        assert!(valid.is_valid());
    }

    #[test]
    fn test_event_material_extraction() {
        let mut event = Event::new(0, 0, EventType::StateChange);
        event.payload[0] = 0x05; // old material low byte
        event.payload[1] = 0x00; // old material high byte
        event.payload[2] = 0x0A; // new material low byte
        event.payload[3] = 0x00; // new material high byte

        assert_eq!(event.old_material(), 5);
        assert_eq!(event.new_material(), 10);
    }
}
